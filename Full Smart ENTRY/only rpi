Of course. Removing the face recognition simplifies the script significantly, turning it into a manual control system with a live camera feed. This is a great way to test the mechanical and electronic parts (servo, GUI, camera) before adding more complex logic.

I have refactored the code to remove all components related to face recognition.

### Summary of Changes:

1.  **Removed Libraries:** I've taken out the imports for `face_recognition`, `dlib`, and `numpy`, as they are no longer needed.
2.  **Removed `encode` Mode:** The command-line argument and function `encode_faces()` have been completely removed, as there are no faces to encode. The script now only has one mode: `run`.
3.  **Simplified `update()` Loop:** The main `update()` method in the `SmartGateApp` class has been stripped of all face detection and recognition logic. It now simply captures a frame from the camera and displays it in the GUI.
4.  **Removed Automatic Unlock:** Since there's no face recognition, the automatic unlock trigger has been removed. The gate can now only be operated using the "Manual Unlock" and "Manual Lock" buttons.
5.  **Updated Comments and Docstrings:** I've updated the descriptions and comments throughout the file to reflect its new, simpler functionality.

---

### Revised Code (Without Face Recognition)

Here is the clean, updated script. You can directly replace your old code with this.

```python
# -*- coding: utf-8 -*-
"""
Raspberry Pi Smart Gate Control System
Version: 3.0.0
Author: Khalil L. (Original), AI Assistant (Refactored for Manual Control)

Description:
This script operates a manual smart gate system using a Raspberry Pi 4B.
It provides a graphical user interface (GUI) with a live camera feed to
monitor the gate area and buttons for manual control of a servo motor lock.

This version is designed for direct manual operation and does not include
any automatic features like face recognition.

Setup:
1.  Hardware:
    - Raspberry Pi 4B
    - Camera Module (connected to the Pi)
    - Servo Motor (e.g., SG90) connected to a GPIO pin.
      - Servo VCC (Red wire) -> 5V on Pi (or external supply)
      - Servo GND (Brown wire) -> GND on Pi (and external supply if used)
      - Servo Signal (Orange wire) -> GPIO Pin defined in CONFIG

2.  Software Dependencies:
    - gpiozero: For stable and easy servo control.
    - opencv-python: For camera access and image processing.
    - Pillow (PIL Fork): For integrating video frames into the Tkinter GUI.

    Install dependencies with:
    pip install gpiozero RPi.GPIO opencv-python pillow

Usage:
    python3 smart_gate_manual.py
"""

# --- Standard Library Imports ---
import sys
import tkinter as tk
from tkinter import messagebox

# --- Third-Party Imports ---
import cv2
from gpiozero import Servo
from PIL import Image, ImageTk

# --- Application Configuration ---
CONFIG = {
    # --- Hardware Settings ---
    "servo_pin": 18,              # BCM GPIO pin for the servo signal wire.
    "servo_locked_angle": 0,      # Angle (0-90) for the 'locked' position.
    "servo_unlocked_angle": 90,   # Angle (0-90) for the 'unlocked' position.

    # --- Application Settings ---
    "unlock_duration_sec": 5,     # Duration (in seconds) the gate stays unlocked.
    
    # --- Camera Settings ---
    "camera_index": 0,
    "frame_width": 640,
    "frame_height": 480,
}

class SmartGateApp:
    """
    The main application class that manages the GUI, camera feed,
    and GPIO control for the smart gate.
    """
    def __init__(self, window, window_title):
        """
        Initializes the application, setting up the GUI, camera, and servo.
        """
        self.window = window
        self.window.title(window_title)
        
        self.is_locked = True
        self.unlock_timer = None

        self._setup_gpio()
        self._setup_camera()
        self._setup_gui()

        # Start the main update loop
        self.update()

    def _setup_gpio(self):
        """Sets up the servo motor using gpiozero."""
        print("[INFO] Initializing Servo on GPIO pin", CONFIG["servo_pin"])
        try:
            self.servo = Servo(CONFIG["servo_pin"])
            self.lock()  # Ensure the system starts in a locked state.
        except Exception as e:
            messagebox.showerror("GPIO/Servo Error", f"Failed to initialize servo: {e}\nIs the gpiozero library installed?")
            self.on_close()

    def _setup_camera(self):
        """Initializes the video camera."""
        print(f"[INFO] Initializing camera at index {CONFIG['camera_index']}...")
        self.cap = cv2.VideoCapture(CONFIG["camera_index"])
        if not self.cap.isOpened():
            messagebox.showerror("Camera Error", f"Unable to open camera source {CONFIG['camera_index']}.")
            self.on_close()
            return
        self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, CONFIG["frame_width"])
        self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, CONFIG["frame_height"])
        print("[INFO] Camera initialized successfully.")

    def _setup_gui(self):
        """Creates and arranges the GUI elements."""
        print("[INFO] Setting up GUI...")
        # Video canvas
        self.canvas = tk.Canvas(self.window, width=CONFIG["frame_width"], height=CONFIG["frame_height"])
        self.canvas.pack(padx=10, pady=10, side=tk.TOP, fill="both", expand=True)

        # Status Label
        self.status_label = tk.Label(self.window, text="Status: Locked", font=("Arial", 16, "bold"), fg="#d9534f")
        self.status_label.pack(pady=5)

        # Control Frame
        control_frame = tk.Frame(self.window)
        control_frame.pack(pady=10, fill="x", padx=10)
        
        # Manual Unlock/Lock Buttons
        self.unlock_button = tk.Button(control_frame, text="Manual Unlock", command=self.unlock, width=15, height=2, bg="#5cb85c", fg="white")
        self.unlock_button.pack(side=tk.LEFT, expand=True, fill="x", padx=5)

        self.lock_button = tk.Button(control_frame, text="Manual Lock", command=self.lock, width=15, height=2, bg="#d9534f", fg="white", state=tk.DISABLED)
        self.lock_button.pack(side=tk.RIGHT, expand=True, fill="x", padx=5)
        
        self.window.protocol("WM_DELETE_WINDOW", self.on_close)
        print("[INFO] GUI setup complete.")

    def lock(self):
        """Moves the servo to the 'locked' angle and updates the GUI."""
        self.servo.angle = CONFIG["servo_locked_angle"]
        self.is_locked = True
        self.status_label.config(text="Status: Locked", fg="#d9534f")
        self.lock_button.config(state=tk.DISABLED)
        self.unlock_button.config(state=tk.NORMAL)
        if self.unlock_timer:
            self.window.after_cancel(self.unlock_timer)
            self.unlock_timer = None
        print("[STATE] System LOCKED. Servo at angle:", CONFIG["servo_locked_angle"])
        # Detach the servo after a short delay to prevent jitter and save power
        self.window.after(500, self.servo.detach)

    def unlock(self):
        """Moves the servo to the 'unlocked' angle for a fixed duration."""
        if not self.is_locked: return # Prevent re-triggering unlock
        
        self.servo.angle = CONFIG["servo_unlocked_angle"]
        self.is_locked = False
        duration = CONFIG['unlock_duration_sec']
        self.status_label.config(text=f"Status: Unlocked for {duration}s", fg="#5cb85c")
        self.unlock_button.config(state=tk.DISABLED)
        self.lock_button.config(state=tk.NORMAL)
        
        # Set a timer to automatically re-lock the door
        self.unlock_timer = self.window.after(duration * 1000, self.lock)
        print(f"[STATE] System UNLOCKED for {duration} seconds. Servo at angle:", CONFIG["servo_unlocked_angle"])
        # Detach the servo after a short delay
        self.window.after(500, self.servo.detach)

    def update(self):
        """
        The main loop that captures video frames and displays them in the GUI.
        """
        ret, frame = self.cap.read()
        if not ret:
            print("[ERROR] Failed to capture frame from camera.")
            self.window.after(1000, self.update) # Retry after 1 second
            return

        # Convert the frame for display in Tkinter
        self.photo = ImageTk.PhotoImage(image=Image.fromarray(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)))
        self.canvas.create_image(0, 0, image=self.photo, anchor=tk.NW)

        # Schedule the next update
        self.window.after(15, self.update)

    def on_close(self):
        """Performs cleanup operations when the application window is closed."""
        print("[INFO] Closing application and cleaning up resources...")
        if self.unlock_timer:
            self.window.after_cancel(self.unlock_timer)
        if hasattr(self, 'cap') and self.cap.isOpened():
            self.cap.release()
        if hasattr(self, 'servo'):
            self.servo.close()
        self.window.destroy()
        print("[INFO] Cleanup complete. Exiting.")


if __name__ == "__main__":
    app = None
    try:
        root = tk.Tk()
        app = SmartGateApp(root, "Smart Gate Control System")
        root.mainloop()
    except Exception as e:
        print(f"[CRITICAL] An unexpected error occurred: {e}")
    finally:
        # Ensure cleanup happens even if the app crashes
        if app and hasattr(app, 'servo'):
            app.servo.close()
```
